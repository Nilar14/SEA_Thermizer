---
title: "Prep_plankton_SEA"
output: html_document
date: "2023-10-06"
editor_options: 
  chunk_output_type: console
---

```{r}



# Load total carbon data
GFDL_pico <- read.csv("gfdl-mom6-cobalt2_obsclim_phypico-vint_15arcmin_SEAustralia-mizer_monthly_1961_2010.csv")
GFDL_diat <- read.csv("gfdl-mom6-cobalt2_obsclim_phydiat-vint_15arcmin_seaustralia-mizer_monthly_1961_2010.csv")
GFDL_diaz <- read.csv("gfdl-mom6-cobalt2_obsclim_phydiaz-vint_15arcmin_SEAustralia-mizer_monthly_1961_2010.csv")
GFDL_zmicro <- read.csv("gfdl-mom6-cobalt2_obsclim_zmicro-vint_15arcmin_seaustralia-mizer_monthly_1961_2010.csv")
GFDL_zmeso <- read.csv("gfdl-mom6-cobalt2_obsclim_zmeso-vint_15arcmin_seaustralia-mizer_monthly_1961_2010.csv")

# Create variables for referencing the size class mid points, in gww
pico_mid <- (4/3)*pi*((0.5*0.0001*5.1)^3)
large_mid <- (4/3)*pi*((0.5*0.0001*105)^3)
micro_mid <- (4/3)*pi*((0.5*0.0001*101)^3)
meso_mid <- (4/3)*pi*((0.5*0.0001*10100)^3)

# Convert total carbon to gww and then get numerical abundance by dividing by size class mid point
# This step assumes that all plankton are the midpoint size
pico_abund <- GFDL_pico[,3]*10/pico_mid
large_abund <- (GFDL_diat[,3] + GFDL_diaz[,3])*10/large_mid
micro_abund <- GFDL_zmicro[,3]*10/micro_mid
meso_abund <- GFDL_zmeso[,3]*10/meso_mid

# Combine mid-point sizes for generating the x-axis for the linear fit
plankton_x <- log10(c(pico_mid, micro_mid, large_mid, meso_mid))

# The full spectrum sizes were generated by setting up a mizer params:
Sea_params <- readRDS("final_params_object.rds")
interaction <- Sea_params@interaction
interaction <- as(interaction,"matrix")
params <- newMultispeciesParams(species_params = Sea_params@species_params,interaction = interaction, kappa = 0.002191539)

# and accessing the full size range
log10(params@w_full)

full_x <-log10(params@w_full)


# Creating background resource for full_x, using the actual slope and intercept from the linear models.
# Create array and fill it
out_isimip <- array(numeric(), c(600,226)) # 600 time steps by 226 size classes
isimip_slope <- array(numeric(), c(600,1)) # 600 time steps
isimip_intercept <- array(numeric(), c(600,1)) # 600 time steps


# y values
for (t in seq(1,600,1)) {
	isimip_plankton <- log10(c(pico_abund[t], micro_abund[t], large_abund[t], meso_abund[t]))
		
	# Calculate slope and intercept, expand spectra for full size range
	# Linear fits
	isimip_lm <- lm(isimip_plankton ~ plankton_x)
	
	# Expand to full size range
	out_isimip[t,] <- isimip_lm$coefficients[2] * full_x + isimip_lm$coefficients[1]
	#out_isimip[t,] <- isimip_lm$coefficients[2]*1.03 * full_x + isimip_lm$coefficients[1]*0.85
	# The scaling for the slope and intercept were determined following the method in 
	# Woodworth-Jefcoats et al. (2019)  More information is provided below.
	
	# Save slope and intercept, for diagnostics
	isimip_intercept[t,1] <- isimip_lm$coefficients[1]
	isimip_slope[t,1] <- isimip_lm$coefficients[2]
	
}



# Save
#**write.table(out_isimip, file = "SEAus_GFDL_resource_spectra_S1.03I0.85.dat", quote = FALSE, row.names = TRUE, col.names = TRUE)
write.table(isimip_slope, file = "SEAus_GFDL_resource_slope_S1.03I0.85.dat", quote = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)
write.table(isimip_intercept, file = "SEAus_GFDL_resource_intercept_S1.03I0.85.dat", quote = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)

```